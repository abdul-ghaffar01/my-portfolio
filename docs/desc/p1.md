## Why I Built This

I wanted a personal assistant integrated into my portfolio that could interact with visitors in real time, answer their questions, and demonstrate my full-stack development skills. This chatbot also serves as a showcase of my ability to work with backend APIs, real-time WebSocket connections, containerized deployments, and production-ready server setups.

---

## Architecture Overview

The chatbot is composed of multiple components working together:

1. **Frontend** – A React-based interface embedded in my portfolio site, triggered via a floating chat icon at the bottom-right corner.
2. **Backend API** – Built with Node.js + Express, handling user queries, connecting to an AI processing service, and managing WebSocket communication.
3. **Database** – MongoDB for storing training data, bot responses, and chat history.
4. **Admin Panel** – A separate interface for training the chatbot, adding intents, and updating responses.
5. **Deployment Stack** – Docker containers for the frontend, backend, and database, reverse-proxied through Nginx on a VPS.

---

## Development Workflow

1. **Local Development**

   - I built the backend API with Express and added WebSocket support using `ws` for real-time communication.
   - For the chatbot’s UI, I used React with a simple state management system to handle messages.
   - The admin panel was built in React as well, consuming secure API endpoints for CRUD operations on chatbot training data.

2. **Containerization**

   - Each component (frontend, backend, MongoDB) was containerized using Docker.
   - I wrote individual `Dockerfile`s for each service, ensuring lightweight images and efficient builds.
   - A `docker-compose.yml` file was used locally to spin up the full stack with one command.

3. **Testing**
   - API endpoints were tested using Postman.
   - WebSocket communication was tested with multiple clients connected at the same time.
   - The chatbot UI was integrated into my portfolio to verify responsiveness and smooth animations.

---

## Deployment on VPS

1. **VPS Setup**

   - I rented a VPS with Ubuntu installed.
   - Installed Docker and Docker Compose to manage containers.
   - Configured firewall rules to allow HTTP (80), HTTPS (443), and WebSocket traffic.

2. **File Transfer**

   - The project repository was cloned directly onto the VPS.
   - Environment variables for production were added securely using `.env` files.

3. **Production Docker Compose**

   - In production, I used a separate `docker-compose.yml` to optimize builds and enable restart policies.
   - MongoDB ran as a container with persistent volume storage to ensure data durability.

4. **Nginx Reverse Proxy**

   - Installed Nginx to handle incoming traffic.
   - Configured server blocks so that:
     - `iabdulghaffar.com` served the portfolio site and chatbot frontend.
     - `chatbot.iabdulghaffar.com` proxied to the backend container.
   - Enabled SSL with Let’s Encrypt for HTTPS encryption.

5. **Final Launch**
   - Ran `docker-compose -f docker-compose.yml up -d` to start all containers in detached mode.
   - Verified logs to ensure services started without errors.
   - The chatbot became publicly accessible from my portfolio website, ready to interact with visitors.

---

## Key Takeaways

- **Scalable & Modular** – The architecture is designed so each service can be scaled independently.
- **Secure** – HTTPS encryption, secure WebSocket connections, and restricted API access for the admin panel.
- **Portable** – Thanks to Docker, the entire project can be redeployed anywhere with minimal setup.
- **Professional Deployment** – Using Nginx as a reverse proxy ensures smooth routing and SSL support.

---
